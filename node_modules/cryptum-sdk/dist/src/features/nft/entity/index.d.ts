export type NftInfoInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    tokenUid?: string | undefined;
    tokenAddress?: string | undefined;
};
export type NftInfo = {
    name?: string | undefined;
    symbol?: string | undefined;
    tokenAddress?: string | undefined;
    type?: string | undefined;
    tokenUid?: string | undefined;
    totalSupply?: string | undefined;
    nftData?: string | undefined;
};
export type NftMetadataInput = {
    protocol: string;
    tokenUid?: string;
    tokenAddress?: string;
    tokenId?: string;
};
export type NftMetadata = {
    tokenUid?: string;
    tokenAddress?: string;
    uri: string;
    metadata?: any;
};
export type NftBalanceInfoInput = {
    protocol: string;
    tokenUid?: string;
    tokenAddress?: string;
    tokenId?: string;
    address: string;
};
export type NftBalanceInfo = {
    tokenAddress?: string;
    tokenUid?: string;
    owner: string;
    balance: string;
};
export type NftCreationInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    wallet: import('../../wallet/entity').Wallet;
    /**
     * token name
     */
    name: string;
    /**
     * token symbol
     */
    symbol: string;
    /**
     * amount to be created
     */
    amount: string;
    /**
     * metadata URI string for hathor and solana only, for EVMs this will be the base URI
     */
    uri?: string | undefined;
    /**
     * token type for EVMs only
     */
    type?: ('ERC721' | 'ERC1155') | undefined;
    /**
     * address responsible to mint more tokens (for hathor only)
     */
    mintAuthorityAddress?: string | undefined;
    /**
     * address responsible to burn more tokens (for hathor only)
     */
    meltAuthorityAddress?: string | undefined;
    /**
     * fee currency (for celo only)
     */
    feeCurrency?: string | undefined;
    /**
     * fee
     */
    fee: import("../../transaction/entity").Fee;
    /**
     * true if this token has fixed supply (for solana only)
     */
    creators?: import('../../transaction/entity').SolanaCreator[] | undefined;
    /**
     * (for solana only)
     */
    royaltiesFee?: number | undefined;
    /**
     * (for solana only)
     */
    collection?: string | undefined;
};
export type NftTransferInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    wallet: import('../../wallet/entity').Wallet;
    /**
     * token name or address to transfer
     */
    token: string;
    /**
     * destination address
     */
    destination?: string | undefined;
    /**
     * amount to be transferred
     */
    amount: string | number;
    /**
     * token id to be transferred only for EVMs (ethereum, bsc, celo, polygon, avax)
     */
    tokenId?: string | undefined;
    /**
     * fee currency (for celo only)
     */
    feeCurrency?: string | undefined;
    /**
     * fee
     */
    fee: import("../../transaction/entity").Fee;
};
export type NftMintInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    wallet: import('../../wallet/entity').Wallet;
    /**
     * token address to mint
     */
    token: string;
    /**
     * destination address
     */
    destination: string;
    /**
     * amount to be minted
     */
    amount: string;
    /**
     * token id to be minted only for EVMs (ethereum, bsc, celo, polygon, avax)
     */
    tokenId?: string | undefined;
    /**
     * metadata URI string for EVMs this will be the base URI
     */
    uri?: string | undefined;
    /**
     * mint authority address for hathor only
     */
    mintAuthorityAddress?: string | undefined;
    /**
     * fee currency (for celo only)
     */
    feeCurrency?: string | undefined;
    /**
     * fee
     */
    fee: import("../../transaction/entity").Fee;
};
export type NftBurnInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    wallet: import('../../wallet/entity').Wallet;
    /**
     * token address to burn
     */
    token: string;
    /**
     * amount to be burnt
     */
    amount: string;
    /**
     * token id to be burnt only for EVMs (ethereum, bsc, celo, polygon, avax)
     */
    tokenId?: string | undefined;
    /**
     * melt authority address for hathor only
     */
    meltAuthorityAddress?: string | undefined;
    /**
     * fee currency (for celo only)
     */
    feeCurrency?: string | undefined;
    /**
     * fee
     */
    fee: import("../../transaction/entity").Fee;
};
export type NftApproveInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    wallet: import('../../wallet/entity').Wallet;
    /**
     * token address to invoke the approve method
     */
    token: string;
    /**
     * token id
     */
    tokenId: string;
    /**
     * address to add to the set of authorized operators
     */
    operator: string;
    /**
     * fee currency (for celo only)
     */
    feeCurrency?: string | undefined;
    /**
     * fee
     */
    fee: import("../../transaction/entity").Fee;
};
export type NftSetApprovalForAllInput = {
    protocol: import('../../../services/blockchain/constants').Protocol;
    wallet: import('../../wallet/entity').Wallet;
    /**
     * token address to invoke the approve method
     */
    token: string;
    /**
     * address to add to the set of authorized operators
     */
    operator: string;
    /**
     * true if the operator is approved, false to revoke approval
     */
    isApproved: boolean;
    /**
     * fee currency (for celo only)
     */
    feeCurrency?: string | undefined;
    /**
     * fee
     */
    fee: import("../../transaction/entity").Fee;
};
