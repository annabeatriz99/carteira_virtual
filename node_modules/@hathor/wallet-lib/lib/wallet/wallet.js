"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const constants_1 = require("../constants");
const bitcore_mnemonic_1 = __importDefault(require("bitcore-mnemonic"));
const bitcore_lib_1 = require("bitcore-lib");
const wallet_1 = __importDefault(require("../wallet"));
const walletApi_1 = __importDefault(require("./api/walletApi"));
const wallet_2 = __importDefault(require("../utils/wallet"));
const helpers_1 = __importDefault(require("../utils/helpers"));
const transaction_1 = __importDefault(require("../utils/transaction"));
const tokens_1 = __importDefault(require("../utils/tokens"));
const p2pkh_1 = __importDefault(require("../models/p2pkh"));
const transaction_2 = __importDefault(require("../models/transaction"));
const create_token_transaction_1 = __importDefault(require("../models/create_token_transaction"));
const output_1 = __importDefault(require("../models/output"));
const input_1 = __importDefault(require("../models/input"));
const address_1 = __importDefault(require("../models/address"));
const network_1 = __importDefault(require("../network"));
const assert_1 = __importDefault(require("assert"));
const connection_1 = __importDefault(require("./connection"));
const sendTransactionWalletService_1 = __importDefault(require("./sendTransactionWalletService"));
const bitcore_lib_2 = __importDefault(require("bitcore-lib"));
const types_1 = require("./types");
const errors_1 = require("../errors");
const errorMessages_1 = require("../errorMessages");
// Time in milliseconds berween each polling to check wallet status
// if it ended loading and became ready
const WALLET_STATUS_POLLING_INTERVAL = 3000;
var walletState;
(function (walletState) {
    walletState["NOT_STARTED"] = "Not started";
    walletState["LOADING"] = "Loading";
    walletState["READY"] = "Ready";
})(walletState || (walletState = {}));
class HathorWalletServiceWallet extends events_1.EventEmitter {
    constructor(requestPassword, seed, network, options = { passphrase: '' }) {
        super();
        const { passphrase } = options;
        if (!seed) {
            throw Error('You must explicitly provide the seed.');
        }
        // Setup the connection so clients can listen to its events before it is started
        this.conn = new connection_1.default();
        this.state = walletState.NOT_STARTED;
        // It will throw InvalidWords error in case is not valid
        wallet_2.default.wordsValid(seed);
        this.seed = seed;
        this.passphrase = passphrase;
        this.requestPassword = requestPassword;
        // ID of wallet after created on wallet service
        this.walletId = null;
        this.isSendingTx = false;
        this.txProposalId = null;
        this.xpub = null;
        this.authPrivKey = null;
        this.network = network;
        network_1.default.setNetwork(this.network.name);
        this.authToken = null;
        this.firstConnection = true;
        this.newAddresses = [];
        this.indexToUse = -1;
        // TODO should we have a debug mode?
    }
    /**
     * Remove sensitive data from memory
     *
     * NOTICE: This won't remove data from memory immediately, we have to wait until javascript
     * garbage collect it. JavaScript currently does not provide a standard way to trigger
     * garbage collection
     **/
    clearSensitiveData() {
        this.seed = null;
        this.authPrivKey = null;
    }
    /**
     * Get auth xpubkey from seed
     *
     * @param {String} seed 24 words
     * @param {Object} options Options with passphrase and networkName
     *
     * @return {String} auth xpubkey
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    static getAuthXPubKeyFromSeed(seed, options = {}) {
        const methodOptions = Object.assign({
            passphrase: '',
            networkName: 'mainnet',
        }, options);
        const xpriv = wallet_2.default.getXPrivKeyFromSeed(seed, methodOptions);
        const privkey = HathorWalletServiceWallet.deriveAuthPrivateKey(xpriv);
        return privkey.xpubkey;
    }
    /**
     * Derive private key from root to the auth specific purpose derivation path
     *
     * @param {HDPrivateKey} xpriv The wallet's root xpriv
     *
     * @return {HDPrivateKey} Derived private key at the auth derivation path
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    static deriveAuthPrivateKey(xpriv) {
        return xpriv.deriveNonCompliantChild(constants_1.WALLET_SERVICE_AUTH_DERIVATION_PATH);
    }
    /**
     * getWalletIdFromXPub: Get the wallet id given the xpubkey
     *
     * @param xpub - The xpubkey
     * @returns The wallet id
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    static getWalletIdFromXPub(xpub) {
        return bitcore_lib_1.crypto.Hash.sha256sha256(Buffer.from(xpub)).toString('hex');
    }
    /**
     * Start wallet: load the wallet data, update state and start polling wallet status until it's ready
     *
     * @param {Object} optionsParams Options parameters
     *  {
     *   'pinCode': PIN to encrypt the auth xpriv on storage
     *   'password': Password to decrypt xpriv information
     *  }
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    start({ pinCode, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.seed) {
                throw new Error('Seed should be in memory when starting the wallet.');
            }
            if (!pinCode) {
                throw new Error('Pin code is required when starting the wallet.');
            }
            this.setState(walletState.LOADING);
            const { xpub, authXpub, xpubkeySignature, authXpubkeySignature, timestampNow, firstAddress, authDerivedPrivKey, } = this.generateCreateWalletAuthData(this.seed);
            wallet_1.default.executeGenerateWallet(this.seed, this.passphrase, pinCode, password, false);
            this.xpub = xpub;
            this.authPrivKey = authDerivedPrivKey;
            const handleCreate = (data) => __awaiter(this, void 0, void 0, function* () {
                this.walletId = data.walletId;
                if (data.status === 'creating') {
                    // If the wallet status is creating, we should wait until it is ready
                    // before continuing
                    yield this.pollForWalletStatus();
                }
                else if (data.status !== 'ready') {
                    // At this stage, if the wallet is not `ready` or `creating` we should
                    // throw an error as there are only three states: `ready`, `creating` or `error`
                    throw new errors_1.WalletRequestError(errorMessages_1.ErrorMessages.WALLET_STATUS_ERROR);
                }
                yield this.onWalletReady();
            });
            const data = yield walletApi_1.default.createWallet(this, xpub, xpubkeySignature, authXpub, authXpubkeySignature, timestampNow, firstAddress);
            yield handleCreate(data.status);
            this.clearSensitiveData();
        });
    }
    generateCreateWalletAuthData(seed) {
        const xpriv = wallet_2.default.getXPrivKeyFromSeed(seed, { passphrase: this.passphrase, networkName: this.network.name });
        const xpub = wallet_2.default.getXPubKeyFromSeed(seed, { passphrase: this.passphrase, networkName: this.network.name });
        const authXpub = HathorWalletServiceWallet.getAuthXPubKeyFromSeed(seed, {
            passphrase: this.passphrase,
            networkName: this.network.name,
        });
        const now = new Date();
        const timestampNow = Math.floor(now.getTime() / 1000); // in seconds
        const walletId = HathorWalletServiceWallet.getWalletIdFromXPub(xpub);
        // prove we own the xpubkey
        const xprivAccountPath = wallet_2.default.deriveXpriv(xpriv, '0\'');
        const xpubkeySignature = this.signMessage(xprivAccountPath, timestampNow, walletId);
        // prove we own the auth_xpubkey
        const authDerivedPrivKey = HathorWalletServiceWallet.deriveAuthPrivateKey(xpriv);
        const authXpubkeySignature = this.signMessage(authDerivedPrivKey, timestampNow, walletId);
        const xpubChangeDerivation = wallet_2.default.xpubDeriveChild(xpub, 0);
        const firstAddress = wallet_2.default.getAddressAtIndex(xpubChangeDerivation, 0, this.network.name);
        return {
            xpub,
            xpubkeySignature,
            authXpub,
            authXpubkeySignature,
            timestampNow,
            firstAddress,
            authDerivedPrivKey,
        };
    }
    /**
     * onUpdateTx: Event called when a transaction is updated
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    onUpdateTx(updatedTx) {
        this.emit('update-tx', updatedTx);
    }
    /**
     * onNewTx: Event called when a new transaction is received on the websocket feed
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    onNewTx(newTx) {
        return __awaiter(this, void 0, void 0, function* () {
            const outputs = newTx.outputs;
            let shouldGetNewAddresses = false;
            for (const output of outputs) {
                if (this.newAddresses.find((newAddress) => newAddress.address === output.decoded.address)) {
                    // break early
                    shouldGetNewAddresses = true;
                    break;
                }
            }
            // We need to update the `newAddresses` array on every new transaction
            // because the new tx might have used one of those addresses and we try to guarantee
            // that every transaction uses a new address for increased privacy
            if (shouldGetNewAddresses) {
                yield this.getNewAddresses();
            }
            this.emit('new-tx', newTx);
        });
    }
    /**
     * Return wallet auth token
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getAuthToken() {
        return this.authToken;
    }
    /**
     * Returns the balance for each token in tx, if the input/output belongs to this wallet
     *
     * This method is meant to keep compatibility with the old facade
     *
     * @param {Object} tx Transaction data with array of inputs and outputs
     *
     * @return {Object} Object with each token and it's balance in this tx for this wallet
     **/
    getTxBalance(tx, optionsParam = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Object.assign({ includeAuthorities: false }, optionsParam);
            const addresses = [];
            const generator = this.getAllAddresses();
            // We are not using for async (...) to maintain compatibility with older nodejs versions
            // if we ever deprecate older node versions, we can refactor this to the new, cleaner syntax
            let nextAddress;
            while (!(nextAddress = yield generator.next()).done) {
                addresses.push(nextAddress.value.address);
            }
            const balance = {};
            for (const txout of tx.outputs) {
                if (wallet_1.default.isAuthorityOutput(txout)) {
                    if (options.includeAuthorities) {
                        if (!balance[txout.token]) {
                            balance[txout.token] = 0;
                        }
                    }
                    continue;
                }
                if (txout.decoded && txout.decoded.address
                    && addresses.includes(txout.decoded.address)) {
                    if (!balance[txout.token]) {
                        balance[txout.token] = 0;
                    }
                    balance[txout.token] += txout.value;
                }
            }
            for (const txin of tx.inputs) {
                if (wallet_1.default.isAuthorityOutput(txin)) {
                    if (options.includeAuthorities) {
                        if (!balance[txin.token]) {
                            balance[txin.token] = 0;
                        }
                    }
                    continue;
                }
                if (txin.decoded && txin.decoded.address
                    && addresses.includes(txin.decoded.address)) {
                    if (!balance[txin.token]) {
                        balance[txin.token] = 0;
                    }
                    balance[txin.token] -= txin.value;
                }
            }
            return balance;
        });
    }
    /**
     * When the wallet starts, it might take some seconds for the wallet service to completely load all addresses
     * This method is responsible for polling the wallet status until it's ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    pollForWalletStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const pollIntervalTimer = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    const data = yield walletApi_1.default.getWalletStatus(this);
                    if (data.status.status === 'ready') {
                        clearInterval(pollIntervalTimer);
                        return resolve();
                    }
                    else if (data.status.status !== 'creating') {
                        // Only possible states are 'ready', 'creating' and 'error', if status
                        // is not ready or creating, we should reject the promise
                        clearInterval(pollIntervalTimer);
                        return reject(new errors_1.WalletRequestError('Error getting wallet status.'));
                    }
                }), WALLET_STATUS_POLLING_INTERVAL);
            });
        });
    }
    /**
     * Check if wallet is ready and throw error if not ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    failIfWalletNotReady() {
        if (!this.isReady()) {
            throw new errors_1.WalletError('Wallet not ready');
        }
    }
    /**
     * Method executed when wallet is ready
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    onWalletReady() {
        return __awaiter(this, void 0, void 0, function* () {
            this.setupConnection();
            this.setState(walletState.READY);
            yield this.getNewAddresses();
        });
    }
    setupConnection() {
        if (!this.walletId) {
            // This should never happen
            throw new Error('Tried to setup connection but wallet_id is not set.');
        }
        this.conn.setWalletId(this.walletId);
        this.conn.on('new-tx', (newTx) => this.onNewTx(newTx));
        this.conn.on('update-tx', (updatedTx) => this.onUpdateTx(updatedTx));
        this.conn.on('state', (newState) => this.onConnectionChangedState(newState));
        this.conn.start();
    }
    /**
     * Called when the connection to the websocket changes.
     * It is also called if the network is down.
     *
     * Since the wallet service facade holds no data (as opposed to
     * the old facade, where the wallet facade receives a storage object),
     * the client needs to handle the data reload, so we just emit an event
     * to indicate that a reload is necessary.
     *
     * @param {Number} newState Enum of new state after change
     **/
    onConnectionChangedState(newState) {
        if (newState === types_1.ConnectionState.CONNECTED) {
            // We don't need to reload data if this is the first
            // connection
            if (!this.firstConnection) {
                this.emit('reload-data');
            }
            this.firstConnection = false;
        }
    }
    /**
     * Get all addresses of the wallet
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getAllAddresses() {
        return __asyncGenerator(this, arguments, function* getAllAddresses_1() {
            this.failIfWalletNotReady();
            const data = yield __await(walletApi_1.default.getAddresses(this));
            for (const address of data.addresses) {
                yield yield __await(address);
            }
        });
    }
    /**
     * Get the new addresses to be used by this wallet, i.e. the last GAP LIMIT unused addresses
     * Then it updates this.newAddresses and this.indexToUse that handle the addresses to use
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getNewAddresses() {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getNewAddresses(this);
            this.newAddresses = data.addresses;
            this.indexToUse = 0;
        });
    }
    /**
     * Get the balance of the wallet for a specific token
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getBalance(token = null) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getBalances(this, token);
            return data.balances;
        });
    }
    getTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getTokens(this);
            return data.tokens;
        });
    }
    /**
     * Get the history of the wallet for a specific token
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getTxHistory(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const data = yield walletApi_1.default.getHistory(this, options);
            return data.history;
        });
    }
    /**
     * Get utxo from tx id and index
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getUtxoFromId(txId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield walletApi_1.default.getUtxos(this, { txId, index });
            const utxos = data.utxos;
            if (utxos.length === 0) {
                // No utxo for this txId/index or is not from the requested wallet
                return null;
            }
            else {
                if (utxos.length > 1) {
                    throw new errors_1.UtxoError(`Expected to receive only one utxo for txId ${txId} and index ${index} but received ${utxos.length}.`);
                }
                return utxos[0];
            }
        });
    }
    /**
     * Get utxos for filling a transaction
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getUtxos(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const newOptions = Object.assign({
                tokenId: constants_1.HATHOR_TOKEN_CONFIG.uid,
                authority: null,
                addresses: null,
                totalAmount: null,
                count: 1,
            }, options);
            if (!newOptions.authority && !newOptions.totalAmount) {
                throw new errors_1.UtxoError('We need the total amount of utxos if it\'s not an authority request.');
            }
            newOptions['ignoreLocked'] = true;
            const data = yield walletApi_1.default.getUtxos(this, newOptions);
            let changeAmount = 0;
            let utxos = [];
            if (data.utxos.length === 0) {
                // No utxos available for the requested filter
                utxos = data.utxos;
            }
            else if (newOptions.authority) {
                // Requests an authority utxo, then I return the count of requested authority utxos
                utxos = data.utxos.slice(0, newOptions.count);
            }
            else {
                // We got an array of utxos, then we must check if there is enough amount to fill the totalAmount
                // and slice the least possible utxos
                const ret = transaction_1.default.selectUtxos(data.utxos, newOptions.totalAmount);
                changeAmount = ret.changeAmount;
                utxos = ret.utxos;
            }
            return { utxos, changeAmount };
        });
    }
    /**
     * Signs a message using xpriv derivation path m/44'/280'/0'
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    signMessage(xpriv, timestamp, walletId) {
        const address = xpriv.publicKey.toAddress(this.network.getNetwork()).toString();
        const message = new bitcore_lib_2.default.Message(String(timestamp).concat(walletId).concat(address));
        return message.sign(xpriv.privateKey);
    }
    /**
     * Validate that the wallet auth token is valid
     * If it's not valid, requests a new one and update
     *
     * @param {string} usePassword Accepts the password as a parameter so we don't have to ask
     * the client for it if we already have it in memory
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    validateAndRenewAuthToken(usePassword) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.walletId) {
                throw new Error('Wallet not ready yet.');
            }
            const now = new Date();
            const timestampNow = Math.floor(now.getTime() / 1000);
            const validateJWTExpireDate = (token) => {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace('-', '+').replace('_', '/');
                const decodedData = JSON.parse(Buffer.from(base64, 'base64').toString('binary'));
                // If the token will expire in the next 60 seconds (or has already expired)
                const delta = 60;
                if (timestampNow + delta > decodedData.exp) {
                    return false;
                }
                return true;
            };
            if (!this.authToken || !validateJWTExpireDate(this.authToken)) {
                let privKey = this.authPrivKey;
                if (!privKey) {
                    // Request the client for the PIN
                    const password = usePassword ? usePassword : yield this.requestPassword();
                    // Use it to get the words from the storage
                    privKey = wallet_1.default.getAuthPrivKey(password);
                }
                yield this.renewAuthToken(privKey, timestampNow);
            }
            else {
                // If we have received the user PIN, we should renew the token anyway
                // without blocking this method's promise
                if (usePassword) {
                    const privKey = wallet_1.default.getAuthPrivKey(usePassword);
                    this.renewAuthToken(privKey, timestampNow);
                }
            }
        });
    }
    /**
     * Renew the auth token on the wallet service
     *
     * @param {HDPrivateKey} privKey - private key to sign the auth message
     * @param {number} timestamp - Current timestamp to assemble the signature
     * @param {string} walletId - The initialized wallet identifier on the wallet service
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    renewAuthToken(privKey, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.walletId) {
                throw new Error('Wallet not ready yet.');
            }
            const sign = this.signMessage(privKey, timestamp, this.walletId);
            const data = yield walletApi_1.default.createAuthToken(this, timestamp, privKey.xpubkey, sign);
            this.authToken = data.token;
        });
    }
    /**
     * Creates and send a transaction from an array of inputs and outputs
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    sendManyOutputsTransaction(outputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                inputs: [],
                changeAddress: null
            }, options);
            const { inputs, changeAddress } = newOptions;
            const sendTransaction = new sendTransactionWalletService_1.default(this, { outputs, inputs, changeAddress });
            return sendTransaction.run();
        });
    }
    /**
     * Creates and send a simple transaction with one output
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    sendTransaction(address, value, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                token: '00',
                changeAddress: null
            }, options);
            const { token, changeAddress } = newOptions;
            const outputs = [{ address, value, token }];
            return this.sendManyOutputsTransaction(outputs, { inputs: [], changeAddress });
        });
    }
    /**
     * Calculate input data from dataToSign and addressPath
     * Get the private key corresponding to the addressPath,
     * calculate the signature and add the public key
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getInputData(xprivkey, dataToSignHash, addressPath) {
        const xpriv = bitcore_lib_2.default.HDPrivateKey(xprivkey);
        const derivedKey = xpriv.deriveNonCompliantChild(addressPath);
        const privateKey = derivedKey.privateKey;
        const sig = bitcore_lib_1.crypto.ECDSA.sign(dataToSignHash, privateKey, 'little').set({
            nhashtype: bitcore_lib_1.crypto.Signature.SIGHASH_ALL
        });
        const arr = [];
        helpers_1.default.pushDataToStack(arr, sig.toDER());
        helpers_1.default.pushDataToStack(arr, derivedKey.publicKey.toBuffer());
        return bitcore_lib_1.util.buffer.concat(arr);
    }
    /**
     * Return if wallet is ready to be used
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    isReady() {
        return this.state === walletState.READY;
    }
    /**
     * Update wallet state and emit 'state' event
     *
     * @param {string} state New wallet state
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    setState(state) {
        this.state = state;
        this.emit('state', state);
    }
    /**
     * Stop the wallet
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    stop({ cleanStorage = true } = {}) {
        this.walletId = null;
        this.state = walletState.NOT_STARTED;
        this.firstConnection = true;
        this.removeAllListeners();
        if (cleanStorage) {
            wallet_1.default.cleanWallet({
                endConnection: false,
                connection: this.conn,
            });
        }
        this.conn.stop();
    }
    /**
     * Get address at specific index
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getAddressAtIndex(index) {
        const code = new bitcore_mnemonic_1.default(this.seed);
        const xpriv = code.toHDPrivateKey(this.passphrase, this.network.bitcoreNetwork);
        const privkey = xpriv.deriveNonCompliantChild(`m/44'/${constants_1.HATHOR_BIP44_CODE}'/0'/0`);
        const key = privkey.deriveNonCompliantChild(index);
        const address = bitcore_lib_1.Address(key.publicKey, this.network.getNetwork());
        return address.toString();
    }
    /**
     * Get the current address to be used
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getCurrentAddress({ markAsUsed = false } = {}) {
        const newAddressesLen = this.newAddresses.length;
        if (this.indexToUse > newAddressesLen - 1) {
            const addressInfo = this.newAddresses[newAddressesLen - 1];
            return Object.assign(Object.assign({}, addressInfo), { info: 'GAP_LIMIT_REACHED' });
        }
        const addressInfo = this.newAddresses[this.indexToUse];
        if (markAsUsed) {
            this.indexToUse += 1;
        }
        return addressInfo;
    }
    /**
     * Get the next address after the current available
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    getNextAddress() {
        // First we mark the current address as used, then return the next
        this.getCurrentAddress({ markAsUsed: true });
        return this.getCurrentAddress();
    }
    getAddressIndex(address) {
        throw new errors_1.WalletError('Not implemented.');
    }
    isAddressMine(address) {
        throw new errors_1.WalletError('Not implemented.');
    }
    getTx(id) {
        throw new errors_1.WalletError('Not implemented.');
    }
    getAddressInfo(address, options = {}) {
        throw new errors_1.WalletError('Not implemented.');
    }
    consolidateUtxos(destinationAddress, options = {}) {
        throw new errors_1.WalletError('Not implemented.');
    }
    getFullHistory() {
        throw new errors_1.WalletError('Not implemented.');
    }
    /**
     * Create SendTransaction object and run from mining
     * Returns a promise that resolves when the send succeeds
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    handleSendPreparedTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const sendTransaction = new sendTransactionWalletService_1.default(this, { transaction });
            return sendTransaction.runFromMining();
        });
    }
    /**
     * Prepare create new token data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareCreateNewToken(name, symbol, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createMintAuthority: true,
                createMeltAuthority: true,
                nftData: null,
                pinCode: null,
            }, options);
            const isNFT = newOptions.nftData !== null;
            // 1. Calculate HTR deposit needed
            let deposit = tokens_1.default.getDepositAmount(amount);
            if (isNFT) {
                // For NFT we have a fee of 0.01 HTR, then the deposit utxo query must get an additional 1
                deposit += 1;
            }
            // 2. Get utxos for HTR
            const { utxos, changeAmount } = yield this.getUtxos({ tokenId: constants_1.HATHOR_TOKEN_CONFIG.uid, totalAmount: deposit });
            if (utxos.length === 0) {
                throw new errors_1.UtxoError(`No utxos available to fill the request. Token: HTR - Amount: ${deposit}.`);
            }
            const utxosAddressPath = [];
            // 3. Create the transaction object with the inputs and outputs (new token amount, change address with HTR, mint/melt authorities - depending on parameters)
            const inputsObj = [];
            for (const utxo of utxos) {
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
                utxosAddressPath.push(utxo.addressPath);
            }
            // Create outputs
            const outputsObj = [];
            // NFT transactions must have the first output as the script data
            if (isNFT) {
                outputsObj.push(helpers_1.default.createNFTOutput(newOptions.nftData));
            }
            // a. Token amount
            const addressToUse = newOptions.address || this.getCurrentAddress({ markAsUsed: true }).address;
            const address = new address_1.default(addressToUse, { network: this.network });
            if (!address.isValid()) {
                throw new errors_1.SendTxError(`Address ${newOptions.address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(address);
            const p2pkhScript = p2pkh.createScript();
            outputsObj.push(new output_1.default(amount, p2pkhScript, { tokenData: 1 }));
            if (newOptions.createMintAuthority) {
                // b. Mint authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MINT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (newOptions.createMeltAuthority) {
                // c. Melt authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MELT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (changeAmount) {
                // d. HTR change output
                const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const changeAddress = new address_1.default(changeAddressStr, { network: this.network });
                if (!changeAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
                }
                const p2pkhChange = new p2pkh_1.default(changeAddress);
                const p2pkhChangeScript = p2pkhChange.createScript();
                outputsObj.push(new output_1.default(changeAmount, p2pkhChangeScript));
            }
            const tx = new create_token_transaction_1.default(name, symbol, inputsObj, outputsObj);
            const dataToSignHash = tx.getDataToSignHash();
            if (!newOptions.pinCode) {
                throw new Error('PIN not specified in prepareCreateNewToken options');
            }
            const xprivkey = wallet_1.default.getXprivKey(newOptions.pinCode);
            for (const [idx, inputObj] of tx.inputs.entries()) {
                const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(utxosAddressPath[idx]));
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Expects a BIP44 path at the address level and returns the address index
     *
     * @param {string} fullPath - The full BIP44 path for the address index
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    static getAddressIndexFromFullPath(fullPath) {
        const parts = fullPath.split('/');
        assert_1.default.equal(6, parts.length);
        return parseInt(parts[5], 10);
    }
    /**
     * Create a new custom token in the network
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    createNewToken(name, symbol, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareCreateNewToken(name, symbol, amount, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Prepare mint token data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareMintTokensData(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createAnotherMint: true,
                pinCode: null,
            }, options);
            // 1. Calculate HTR deposit needed
            const deposit = tokens_1.default.getDepositAmount(amount);
            // 2. Get utxos for HTR
            const { utxos, changeAmount } = yield this.getUtxos({ tokenId: constants_1.HATHOR_TOKEN_CONFIG.uid, totalAmount: deposit });
            if (utxos.length === 0) {
                throw new errors_1.UtxoError(`No utxos available to fill the request. Token: HTR - Amount: ${deposit}.`);
            }
            // 3. Get mint authority
            const ret = yield this.getUtxos({ tokenId: token, authority: constants_1.TOKEN_MINT_MASK });
            if (ret.utxos.length === 0) {
                throw new errors_1.UtxoError(`No authority utxo available for minting tokens. Token: ${token}.`);
            }
            // it's safe to assume that we have an utxo in the array
            const mintUtxo = ret.utxos[0];
            // 4. Create inputs from utxos
            const inputsObj = [];
            for (const utxo of utxos) {
                // First add HTR utxos
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            }
            // Then add a single mint authority utxo
            inputsObj.push(new input_1.default(mintUtxo.txId, mintUtxo.index));
            // Create outputs
            const outputsObj = [];
            // a. Token amount
            const addressToUse = newOptions.address || this.getCurrentAddress({ markAsUsed: true }).address;
            const address = new address_1.default(addressToUse, { network: this.network });
            if (!address.isValid()) {
                throw new errors_1.SendTxError(`Address ${newOptions.address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(address);
            const p2pkhScript = p2pkh.createScript();
            outputsObj.push(new output_1.default(amount, p2pkhScript, { tokenData: 1 }));
            if (newOptions.createAnotherMint) {
                // b. Mint authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MINT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (changeAmount) {
                // c. HTR change output
                const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const changeAddress = new address_1.default(changeAddressStr, { network: this.network });
                if (!changeAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
                }
                const p2pkhChange = new p2pkh_1.default(changeAddress);
                const p2pkhChangeScript = p2pkhChange.createScript();
                outputsObj.push(new output_1.default(changeAmount, p2pkhChangeScript));
            }
            const tx = new transaction_2.default(inputsObj, outputsObj);
            tx.tokens = [token];
            const dataToSignHash = tx.getDataToSignHash();
            if (!newOptions.pinCode) {
                throw new Error('PIN not specified in prepareMintTokensData options');
            }
            const xprivkey = wallet_1.default.getXprivKey(newOptions.pinCode);
            for (const [idx, inputObj] of tx.inputs.entries()) {
                // We have an array of utxos and the last input is the one with the authority
                const addressPath = idx === tx.inputs.length - 1 ? mintUtxo.addressPath : utxos[idx].addressPath;
                const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(addressPath));
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Mint new token units
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    mintTokens(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareMintTokensData(token, amount, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Prepare melt token data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareMeltTokensData(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createAnotherMelt: true,
                pinCode: null,
            }, options);
            // 1. Calculate HTR deposit needed
            const withdraw = tokens_1.default.getWithdrawAmount(amount);
            // 2. Get utxos for custom token to melt
            const { utxos, changeAmount } = yield this.getUtxos({ tokenId: token, totalAmount: amount });
            if (utxos.length === 0) {
                throw new errors_1.UtxoError(`Not enough tokens to be melted. Token: ${token} - Amount: ${amount}.`);
            }
            // 3. Get mint authority
            const ret = yield this.getUtxos({ tokenId: token, authority: constants_1.TOKEN_MELT_MASK });
            if (ret.utxos.length === 0) {
                throw new errors_1.UtxoError(`No authority utxo available for melting tokens. Token: ${token}.`);
            }
            // it's safe to assume that we have an utxo in the array
            const meltUtxo = ret.utxos[0];
            // 4. Create inputs from utxos
            const inputsObj = [];
            for (const utxo of utxos) {
                // First add HTR utxos
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            }
            // Then add a single mint authority utxo (it's safe to assume that we have an utxo in the array)
            inputsObj.push(new input_1.default(meltUtxo.txId, meltUtxo.index));
            // Create outputs
            const outputsObj = [];
            // a. Deposit back
            const addressToUse = newOptions.address || this.getCurrentAddress({ markAsUsed: true }).address;
            const address = new address_1.default(addressToUse, { network: this.network });
            if (!address.isValid()) {
                throw new errors_1.SendTxError(`Address ${newOptions.address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(address);
            const p2pkhScript = p2pkh.createScript();
            if (withdraw) {
                // We may have nothing to get back
                outputsObj.push(new output_1.default(withdraw, p2pkhScript, { tokenData: 0 }));
            }
            if (newOptions.createAnotherMelt) {
                // b. Mint authority
                outputsObj.push(new output_1.default(constants_1.TOKEN_MELT_MASK, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            if (changeAmount) {
                // c. Token change output
                const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const changeAddress = new address_1.default(changeAddressStr, { network: this.network });
                if (!changeAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
                }
                const p2pkhChange = new p2pkh_1.default(changeAddress);
                const p2pkhChangeScript = p2pkhChange.createScript();
                outputsObj.push(new output_1.default(changeAmount, p2pkhChangeScript, { tokenData: 1 }));
            }
            const tx = new transaction_2.default(inputsObj, outputsObj);
            tx.tokens = [token];
            const dataToSignHash = tx.getDataToSignHash();
            if (!newOptions.pinCode) {
                throw new Error('PIN not specified in prepareMeltTokensData options');
            }
            const xprivkey = wallet_1.default.getXprivKey(newOptions.pinCode);
            for (const [idx, inputObj] of tx.inputs.entries()) {
                // We have an array of utxos and the last input is the one with the authority
                const addressPath = idx === tx.inputs.length - 1 ? meltUtxo.addressPath : utxos[idx].addressPath;
                const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(addressPath));
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Melt custom token units
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    meltTokens(token, amount, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareMeltTokensData(token, amount, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Prepare delegate authority data, sign the inputs and returns an object ready to be mined
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareDelegateAuthorityData(token, type, address, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                anotherAuthorityAddress: null,
                createAnotherAuthority: true,
                pinCode: null,
            }, options);
            let authority, mask;
            if (type === 'mint') {
                authority = 1;
                mask = constants_1.TOKEN_MINT_MASK;
            }
            else if (type === 'melt') {
                authority = 2;
                mask = constants_1.TOKEN_MELT_MASK;
            }
            else {
                throw new errors_1.WalletError('Type options are mint and melt for delegate authority method.');
            }
            // 1. Get authority utxo to spend
            const ret = yield this.getUtxos({ tokenId: token, authority });
            if (ret.utxos.length === 0) {
                throw new errors_1.UtxoError(`No authority utxo available for delegating authority. Token: ${token} - Type ${type}.`);
            }
            // it's safe to assume that we have an utxo in the array
            const utxo = ret.utxos[0];
            // 2. Create input from utxo
            const inputsObj = [];
            inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            // Create outputs
            const outputsObj = [];
            const addressObj = new address_1.default(address, { network: this.network });
            if (!addressObj.isValid()) {
                throw new errors_1.SendTxError(`Address ${address} is not valid.`);
            }
            const p2pkh = new p2pkh_1.default(addressObj);
            const p2pkhScript = p2pkh.createScript();
            outputsObj.push(new output_1.default(mask, p2pkhScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            if (newOptions.createAnotherAuthority) {
                const anotherAddressStr = newOptions.anotherAuthorityAddress || this.getCurrentAddress({ markAsUsed: true }).address;
                const anotherAddress = new address_1.default(anotherAddressStr, { network: this.network });
                if (!anotherAddress.isValid()) {
                    throw new errors_1.SendTxError(`Address ${newOptions.anotherAuthorityAddress} is not valid.`);
                }
                const p2pkhAnotherAddress = new p2pkh_1.default(anotherAddress);
                const p2pkhAnotherAddressScript = p2pkhAnotherAddress.createScript();
                outputsObj.push(new output_1.default(mask, p2pkhAnotherAddressScript, { tokenData: constants_1.AUTHORITY_TOKEN_DATA }));
            }
            const tx = new transaction_2.default(inputsObj, outputsObj);
            tx.tokens = [token];
            if (!newOptions.pinCode) {
                throw new Error('PIN not specified in prepareDelegateAuthorityData options');
            }
            const xprivkey = wallet_1.default.getXprivKey(newOptions.pinCode);
            // Set input data
            const dataToSignHash = tx.getDataToSignHash();
            const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(utxo.addressPath));
            inputsObj[0].setData(inputData);
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Transfer (delegate) authority outputs to another address
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    delegateAuthority(token, type, address, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareDelegateAuthorityData(token, type, address, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Destroy authority outputs
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    prepareDestroyAuthorityData(token, type, count, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                pinCode: null,
            }, options);
            let authority, mask;
            if (type === 'mint') {
                authority = 1;
                mask = constants_1.TOKEN_MINT_MASK;
            }
            else if (type === 'melt') {
                authority = 2;
                mask = constants_1.TOKEN_MELT_MASK;
            }
            else {
                throw new errors_1.WalletError('Type options are mint and melt for destroy authority method.');
            }
            // 1. Get authority utxo to spend
            const ret = yield this.getUtxos({ tokenId: token, authority, count });
            if (ret.utxos.length < count) {
                throw new errors_1.UtxoError(`Not enough authority utxos available for destroying. Token: ${token} - Type ${type}. Requested quantity ${count} - Available quantity ${ret.utxos.length}`);
            }
            // 1. Create input from utxo
            const inputsObj = [];
            for (const utxo of ret.utxos) {
                inputsObj.push(new input_1.default(utxo.txId, utxo.index));
            }
            // No outputs because we are just destroying the authority utxos
            const tx = new transaction_2.default(inputsObj, []);
            tx.tokens = [token];
            // Set input data
            const dataToSignHash = tx.getDataToSignHash();
            if (!newOptions.pinCode) {
                throw new Error('PIN not specified in prepareDestroyAuthorityData options');
            }
            const xprivkey = wallet_1.default.getXprivKey(newOptions.pinCode);
            for (const [idx, inputObj] of tx.inputs.entries()) {
                const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(ret.utxos[idx].addressPath));
                inputObj.setData(inputData);
            }
            tx.prepareToSend();
            return tx;
        });
    }
    /**
     * Destroy authority outputs
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    destroyAuthority(token, type, count, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const tx = yield this.prepareDestroyAuthorityData(token, type, count, options);
            return this.handleSendPreparedTransaction(tx);
        });
    }
    /**
     * Create an NFT in the network
     *
     * @memberof HathorWalletServiceWallet
     * @inner
     */
    createNFT(name, symbol, amount, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.failIfWalletNotReady();
            const newOptions = Object.assign({
                address: null,
                changeAddress: null,
                createMintAuthority: false,
                createMeltAuthority: false,
            }, options);
            newOptions['nftData'] = data;
            const tx = yield this.prepareCreateNewToken(name, symbol, amount, newOptions);
            return this.handleSendPreparedTransaction(tx);
        });
    }
}
exports.default = HathorWalletServiceWallet;
//# sourceMappingURL=wallet.js.map