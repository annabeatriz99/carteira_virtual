"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const bitcore_lib_1 = require("bitcore-lib");
const network_1 = __importDefault(require("./network"));
const lodash_1 = __importDefault(require("lodash"));
const helpers_1 = __importDefault(require("../utils/helpers"));
class Address {
    constructor(base58, options = { network: new network_1.default('testnet') }) {
        const { network } = options;
        if (!lodash_1.default.isString(base58)) {
            throw Error('Parameter should be a string.');
        }
        this.base58 = base58;
        this.network = network;
    }
    /**
     * Check if address is a valid string
     *
     * @return {boolean} If address is valid
     * @memberof Address
     * @inner
     */
    isValid() {
        try {
            return this.validateAddress();
        }
        catch (e) {
            if (e instanceof errors_1.AddressError) {
                return false;
            }
            throw e;
        }
    }
    /**
     * Decode address in base58 to bytes
     *
     * @return {Buffer} address in bytes
     * @memberof Address
     * @inner
     */
    decode() {
        try {
            return bitcore_lib_1.encoding.Base58.decode(this.base58);
        }
        catch (e) {
            throw new errors_1.AddressError('Invalid base58 address');
        }
    }
    /**
     * Validate address
     *
     * 1. Address must have 25 bytes
     * 2. Address checksum must be valid
     * 3. Address first byte must match one of the options for P2PKH or P2SH
     *
     * @throws {AddressError} Will throw an error if address is not valid
     *
     * @return {boolean}
     * @memberof Address
     * @inner
     */
    validateAddress() {
        const addressBytes = this.decode();
        const errorMessage = `Invalid address: ${this.base58}.`;
        // Validate address length
        if (addressBytes.length !== 25) {
            throw new errors_1.AddressError(`${errorMessage} Address has ${addressBytes.length} bytes and should have 25.`);
        }
        // Validate address checksum
        const checksum = addressBytes.slice(-4);
        const addressSlice = addressBytes.slice(0, -4);
        const correctChecksum = helpers_1.default.getChecksum(addressSlice);
        if (!bitcore_lib_1.util.buffer.equals(checksum, correctChecksum)) {
            throw new errors_1.AddressError(`${errorMessage} Invalid checksum. Expected: ${correctChecksum} != Received: ${checksum}.`);
        }
        // Validate version byte. Should be the p2pkh or p2sh
        const firstByte = addressBytes[0];
        if (!this.network.isVersionByteValid(firstByte)) {
            throw new errors_1.AddressError(`${errorMessage} Invalid network byte. Expected: ${this.network.versionBytes.p2pkh} or ${this.network.versionBytes.p2sh} and received ${firstByte}.`);
        }
        return true;
    }
    /**
     * Get address type
     *
     * Will check the version byte of the address against the network's version bytes.
     * Valid types are p2pkh and p2sh.
     *
     * @throws {AddressError} Will throw an error if address is not valid
     *
     * @return {string}
     * @memberof Address
     * @inner
     */
    getType() {
        this.validateAddress();
        const addressBytes = this.decode();
        const firstByte = addressBytes[0];
        if (firstByte === this.network.versionBytes.p2pkh) {
            return 'p2pkh';
        }
        else if (firstByte === this.network.versionBytes.p2sh) {
            return 'p2sh';
        }
        else {
            throw new errors_1.AddressError('Invalid address type.');
        }
    }
}
exports.default = Address;
//# sourceMappingURL=address.js.map