"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const opcodes_1 = require("../opcodes");
const bitcore_lib_1 = require("bitcore-lib");
const helpers_1 = __importDefault(require("../utils/helpers"));
class P2SH {
    constructor(address, options = {}) {
        const newOptions = Object.assign({
            timelock: null,
        }, options);
        const { timelock } = newOptions;
        if (!address) {
            throw Error('You must provide an address.');
        }
        this.address = address;
        this.timelock = timelock;
    }
    /**
     * Get script type
     *
     * @return {String}
     * @memberof P2SH
     * @inner
     */
    getType() {
        return 'p2sh';
    }
    /**
     * Create a P2SH script
     *
     * @return {Buffer}
     * @memberof P2SH
     * @inner
     */
    createScript() {
        const arr = [];
        const addressBytes = this.address.decode();
        const addressHash = addressBytes.slice(1, -4);
        if (this.timelock) {
            let timelockBytes = helpers_1.default.intToBytes(this.timelock, 4);
            helpers_1.default.pushDataToStack(arr, timelockBytes);
            arr.push(opcodes_1.OP_GREATERTHAN_TIMESTAMP);
        }
        arr.push(opcodes_1.OP_HASH160);
        // addressHash has a fixed size of 20 bytes, so no need to push OP_PUSHDATA1
        arr.push(helpers_1.default.intToBytes(addressHash.length, 1));
        arr.push(addressHash);
        arr.push(opcodes_1.OP_EQUAL);
        return bitcore_lib_1.util.buffer.concat(arr);
    }
    /**
     * Identify a script as P2SH or not.
     *
     * @param {Buffer} buf Script as buffer.
     *
     * @return {Boolean}
     * @memberof P2SH
     * @inner
     */
    static identify(buf) {
        const op_greaterthan_timestamp = opcodes_1.OP_GREATERTHAN_TIMESTAMP.readUInt8();
        const op_hash160 = opcodes_1.OP_HASH160.readUInt8();
        const op_equal = opcodes_1.OP_EQUAL.readUInt8();
        if (buf.length !== 29 && buf.length !== 23) {
            // this is not a P2PKH script
            return false;
        }
        let ptr = 0;
        if (buf.length === 29) {
            // with timelock, we begin with timestamp
            if (buf.readUInt8(ptr++) !== 4) {
                return false;
            }
            ptr += 4;
            // next byte is OP_GREATERTHAN_TIMESTAMP
            if (buf.readUInt8(ptr++) !== op_greaterthan_timestamp) {
                return false;
            }
        }
        // OP_HASH160
        if (buf.readUInt8(ptr++) !== op_hash160) {
            return false;
        }
        // address hash
        if (buf.readUInt8(ptr++) !== 20) {
            return false;
        }
        ptr += 20;
        // OP_EQUAL
        if (buf.readUInt8(ptr++) !== op_equal) {
            return false;
        }
        return true;
    }
}
exports.default = P2SH;
//# sourceMappingURL=p2sh.js.map