"use strict";
/**
 * Copyright (c) Hathor Labs and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_WS_OPTIONS = void 0;
const events_1 = require("events");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const WS_READYSTATE_READY = 1;
exports.DEFAULT_WS_OPTIONS = {
    wsURL: 'wss://node1.mainnet.hathor.network/v1a/',
    heartbeatInterval: 3000,
    connectionTimeout: 5000,
    retryConnectionInterval: 1000,
    openConnectionTimeout: 20000,
};
/**
 * Handles websocket connections and message transmission
 *
 * @class
 * @name WS
 */
class BaseWebSocket extends events_1.EventEmitter {
    constructor(options) {
        super();
        const { wsURL, heartbeatInterval, connectionTimeout, retryConnectionInterval, openConnectionTimeout, } = Object.assign(Object.assign({}, exports.DEFAULT_WS_OPTIONS), options);
        this.WebSocket = isomorphic_ws_1.default;
        this.wsURL = wsURL;
        this.started = false;
        this.connected = false;
        this.isOnline = false;
        this.heartbeatInterval = heartbeatInterval;
        this.connectionTimeout = connectionTimeout;
        this.retryConnectionInterval = retryConnectionInterval;
        this.openConnectionTimeout = openConnectionTimeout;
        this.connectedDate = null;
        this.latestSetupDate = null;
        this.latestPingDate = null;
        this.latestRTT = null;
        this.timeoutTimer = null;
        this.heartbeat = null;
    }
    /**
     * Return websocket url to connect to.
     **/
    getWSServerURL() {
        if (typeof this.wsURL === 'function') {
            return this.wsURL();
        }
        else {
            return this.wsURL;
        }
    }
    /**
     * Start websocket object and its methods
     */
    setup() {
        if (this.started) {
            return;
        }
        const wsURL = this.getWSServerURL();
        if (wsURL === null) {
            throw new Error('No server URL specified.');
        }
        if (this.ws) {
            if (this.latestSetupDate) {
                // This check is just to prevent trying to open
                // a connection more than once within the open timeout
                const dt = (new Date().getTime() - this.latestSetupDate.getTime()) / 1000;
                if (dt < this.openConnectionTimeout) {
                    return;
                }
            }
            this.ws.onclose = () => { };
            this.ws.close();
            this.ws = null;
        }
        this.ws = new this.WebSocket(wsURL);
        this.latestSetupDate = new Date();
        this.ws.onopen = () => this.onOpen();
        this.ws.onmessage = (evt) => this.onMessage(evt);
        this.ws.onerror = (evt) => this.onError(evt);
        this.ws.onclose = () => this.onClose();
    }
    /**
     * Return connection uptime in seconds (or null if not connected).
     **/
    uptime() {
        if (!this.connectedDate) {
            return null;
        }
        const now = new Date().getTime();
        return (now - this.connectedDate.getTime()) / 1000;
    }
    onPong() {
        if (this.latestPingDate) {
            const dt = (new Date().getTime() - this.latestPingDate.getTime()) / 1000;
            this.latestRTT = dt;
            this.latestPingDate = null;
        }
        if (this.timeoutTimer) {
            clearTimeout(this.timeoutTimer);
            this.timeoutTimer = null;
        }
    }
    /**
     * Method called when websocket connection is opened
     */
    onOpen() {
        this.connected = true;
        this.connectedDate = new Date();
        this.started = true;
        this.heartbeat = setInterval(() => {
            this.sendPing();
        }, this.heartbeatInterval);
    }
    /**
     * Method called when websocket connection is closed
     */
    onClose() {
        this.started = false;
        this.connected = false;
        this.connectedDate = null;
        this.setIsOnline(false);
        if (this.ws) {
            this.ws.onclose = () => { };
            this.ws.close();
            this.ws = null;
        }
        setTimeout(() => this.setup(), this.retryConnectionInterval);
        // @ts-ignore
        clearInterval(this.heartbeat);
    }
    /**
     * Method called when an error happend on websocket
     */
    onError(evt) {
        this.emit('connection_error', evt);
        this.onClose();
    }
    /**
     * Method called to send a message to the server
     */
    sendMessage(msg) {
        if (!this.started) {
            this.setIsOnline(false);
            return;
        }
        if (this.ws.readyState === WS_READYSTATE_READY) {
            this.ws.send(msg);
        }
        else {
            // If it is still connecting, we wait a little and try again
            setTimeout(() => {
                this.sendMessage(msg);
            }, 1000);
        }
    }
    /**
     * Ping method to check if server is still alive
     */
    sendPing() {
        if (this.latestPingDate) {
            // Skipping sendPing. Still waiting for pong...
            return;
        }
        const msg = this.getPingMessage();
        this.latestPingDate = new Date();
        this.timeoutTimer = setTimeout(() => this.onConnectionDown(), this.connectionTimeout);
        this.sendMessage(msg);
    }
    /**
     * Event received when the websocket connection is down.
     */
    onConnectionDown() {
        console.warn('Ping timeout. Connection is down...', {
            uptime: this.uptime(),
            connectionTimeout: this.connectionTimeout,
        });
        this.onClose();
    }
    ;
    /**
     * Method called to end a websocket connection
     */
    endConnection() {
        this.setIsOnline(false);
        this.started = false;
        this.connected = null;
        if (this.ws) {
            this.ws.onclose = () => { };
            this.ws.close();
            this.ws = null;
        }
        // @ts-ignore
        clearInterval(this.heartbeat);
    }
    /**
     * Set if websocket is online
     */
    setIsOnline(value) {
        if (this.isOnline !== value) {
            this.isOnline = value;
            // Emits event of online state change
            this.emit('is_online', value);
        }
    }
}
exports.default = BaseWebSocket;
//# sourceMappingURL=base.js.map